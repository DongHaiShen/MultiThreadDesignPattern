[TOC]

## 11.1 Thread-Specific Storage模式

1. 有一个储物间，里面并排摆放着许多储物柜。一个人拿着自己的钥匙进入了储物间，出来时手上拿着自己的行李。别人也拿着自己的钥匙进入了储物间。但是，虽然进人的是同一个储物间，打开的当然是另外一个储物柜。使用者都会从各自的储物柜中取出自己的行李。
2. Specific是 “特定的” 的意思，Storage是储存柜、存储装置的意思。因此，所谓 Thread-Specific Storage 就是 “每个线程特有的存储柜”、“**为每个线程准备的存储空间**” 的意思。
3. Thread-Specific Storage模式是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。



## 11.2 java.lang.ThreadLocal

### 11.2.1 java.lang.ThreadLocal 就是储物间

1. 将 Java.lang.ThreadLocal 的实例当作一种集合可能会有助于大家理解它。也就是说，**一个ThreadLocal的实例会管理多个对象**。
2. ThreadLocal 类的 set 方法用于将通过参数接收的实例与调用该方法的线程（当前线程）对应并存储起来。这里存储的对象可以通过get方法获取。set方法中没有表示线程的参数。set方法会**先查询当前线程**（即表达式Thread.currentThread（）的值），然后以它作为键来存储实例。
3. ThreadLocal 类的 get 方法用于获取与调用 get 方法的线程（当前线程）对应的实例。该线程之前通过 set 方法存储的实例就是 get 方法的返回值。如果之前一次都还没有调用过 set 方法，则 get方法的返回值为null。

### 11.2.2 java.lang.ThreadLocal 与泛型

1. java.lang.ThreadLocal是一个泛型类，可以通过参数的类型来指定要存储的对象的类型。ThreadLocal 类的声明大致如下：

```java
public class ThreadLocal <T>
{
	//存储
	public void set (T value) 
	{
		...
	}
	
	//获取
	public T get ()
	{
		...
	}
	
	...
}
```
2. 即通过 `ThreadLocal<T>` 的 T 指定的类型就是 set 方法的参数的类型以及 get 方法的返回值的类型。



## 11.5 Thread-Specific Storage模式中的角色

### 11.5.1 Client（委托者）
1. Client 角色将处理委托给 TSObjectProxy 角色。一个 TSObjectProxy 角色会被多个 Client 角色使用。

### 11.5.2 TSObjectProxy（线程特有的对象的代理人）
1. TSObjectProxy 角色会执行多个Client角色委托给它的处理。
2. 首先，TSObjectProxy 角色使用 **TSObjectCollection** 角色获取与 Client 角色对应的TSObject 角色。接着，它将处理委托给TSObject角色。

### 11.5.3 TSObjectCollection（线程特有的对象的集合）
1. TSObjectCollection 角色有一张 **Client 角色与 TSObject 角色之间的对应表**。当 `getTSObject()`方法被调用后，它会去查看对应表，返回与 Client 角色相对应的 TSObject 角色。另外，当`setTSObject()`方法被调用后，它会将 Client 角色与 TSObject 角色之间的键值对应关系设置到对应表中。
2. 在示例程序中，由 Java.lang.ThreadLocal 类扮演此角色。

### 11.5.4 TSObject（线程特有的对象）
1. TSObject 角色中保存着线程特有的信息。
2. TSObject 角色由 TSObjectCollection 角色管理。TSObject角色的方法只会被单线程调用。

### 11.5.5 类图与时序图

![类图](http://ww1.sinaimg.cn/large/d8e93840ly1g1d3e41ra0j20v80hpn3h.jpg)

![新创建TSObject角色](http://ww1.sinaimg.cn/large/d8e93840ly1g1d3fgu23xj20j70i80w8.jpg)

![Client访问各自TSObject](http://ww1.sinaimg.cn/large/d8e93840ly1g1d3fvx4cuj20jh0dymzt.jpg)



## 11.6 拓展思路的要点

### 11.6.1 局部变量与 java.lang.ThreadLocal 类
1. 线程本来都是有自己特有的存储空间的，即用于保存方法的局部变量的栈。方法中定义的局部变量属于该线程特有，其他线程无法访问它们。但是，**这些变量在方法调用结束后就会消失**。而 ThreadLocal 则与方法调用无关，它是一个**用于为线程分配特有的存储空间的类**。

### 11.6.2 保存线程特有的信息的位置
1. 线程特有的信息的 “保存位置” 有以下两种：
    + 线程外（thread-external）
    + 线程内（thread-internal）

#### 11.6.2.1 在线程外保存线程特有的信息
1. 示例程序中的线程特有的信息是 TSLog 的实例，而所有的 TSLog 的实例都被保存在 Log 类中的Java.lang.ThreadLocal 的实例中。
2. ThreadLocal 的实例就是储物间，各个线程的储物柜都被集中在这个储物间内。线程并不会背着储物柜四处走动。
  像这样，将线程特有的信息保存在线程外部的方法称为“线程外”。将线程特有的信息保存在线程外部的方法不需要修改既有的表示线程的类（在示例程序2中是ClientThread类），所以可以适用于任何线程。但是，随之而来的是表示线程的类的代码可能会变得难以理解。这是因为，仅仅查看表示线程的类的源代码是无法知道其他类中是否还保存着线程特有的信息的。












